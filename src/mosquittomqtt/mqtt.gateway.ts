import { WebSocketGateway, WebSocketServer, OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect, SubscribeMessage } from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { MqttService } from './mosquittomqtt.service';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Topic } from './entities/mqtt.entity';

@WebSocketGateway({ cors: true })
export class MqttGateway implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer() server: Server;

  constructor(
    private readonly mqttService: MqttService,
    @InjectRepository(Topic)
    private readonly topicRepository: Repository<Topic>,
  ) {}


  afterInit(server: Server) {
    console.log('üöÄ WebSocket Gateway Inicializado');
    this.mqttService.setSocketServer(server);
  }

  handleConnection(client: Socket) {
    console.log(`‚úÖ Cliente conectado: ${client.id}`);
    console.log('Direcci√≥n IP:', client.handshake.address);
    // console.log('Headers:', client.handshake.headers);
  }

  handleDisconnect(client: Socket) {
    console.log(`‚ùå Cliente desconectado: ${client.id}`);

     // Obtener los t√≥picos a los que estaba suscrito
     const topics = Array.from(client.rooms);
     topics.forEach((topic) => {
       if (topic !== client.id) { // Ignorar la sala propia del cliente
         console.log(`Desuscribiendo al cliente de ${topic}`);
         // Aqu√≠ puedes actualizar la base de datos o realizar otras acciones
       }
     });
  }



  @SubscribeMessage('subscribe')
  async handleSubscribe(client: Socket, topic: string) {
    console.log(`‚úÖ Cliente ${client.id} se suscribi√≥ a ${topic}`);

     // Actualizar la base de datos con la nueva suscripci√≥n
     await this.updateTopicSubscriptionCount(topic, 1);

    // Contar suscriptores por t√≥pico
    const topicSubscribers = this.countSubscribers();
    console.log('N√∫mero de suscriptores por t√≥pico:', topicSubscribers);
  }

  @SubscribeMessage('unsubscribe')
  async handleUnsubscribe(client: Socket, topic: string) {
    console.log(`‚ùå Cliente ${client.id} se desuscribi√≥ de ${topic}`);

    // Actualizar la base de datos con la desuscripci√≥n
    await this.updateTopicSubscriptionCount(topic, -1);
   
    // Contar suscriptores por t√≥pico
    const topicSubscribers = this.countSubscribers();
    console.log('N√∫mero de suscriptores por t√≥pico:', topicSubscribers);
  }

  // M√©todo para contar suscriptores por t√≥pico
  countSubscribers(): Map<string, number> {
    const topicSubscribers = new Map<string, number>();

    this.server.sockets.sockets.forEach((client) => {
      const topics = Array.from(client.rooms);
      topics.forEach((topic) => {
        if (topic !== client.id) { // Ignorar la sala propia del cliente
          const count = topicSubscribers.get(topic) || 0;
          topicSubscribers.set(topic, count + 1);
        }
      });
    });

    return topicSubscribers;
  }



  // M√©todo para actualizar el contador de suscripciones en la base de datos
  private async updateTopicSubscriptionCount(topicName: string, change: number): Promise<void> {
    const topic = await this.topicRepository.findOne({ where: { name: topicName } });

    if (topic) {
      topic.subscriptionCount += change;
      await this.topicRepository.save(topic);
    } else if (change > 0) {
      // Si el t√≥pico no existe y es una suscripci√≥n, crea un nuevo registro
      const newTopic = this.topicRepository.create({ name: topicName, subscriptionCount: 1 });
      await this.topicRepository.save(newTopic);
    }
  }




}
